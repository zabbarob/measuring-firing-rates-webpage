<!DOCTYPE html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="bootstrap.min.css" rel="stylesheet" media="screen" />
<link href="bootstrap-responsive.min.css" rel="stylesheet" />
<!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
<!-- [if lt IE 9]>
<script src="http://html5shim.googlecode.com/svn/trunk/html5.js"> </script>
<![endif]-->
<style>
.browser-logos {
    text-align: center;
    margin-top: 1em;
}
.footer {
    text-align: center;
    padding-top: 30px;
    margin-top: 70px;
    border-top: 1px solid #e5e5e5;
    background-color: #f5f5f5;
}
.footer p {
    margin-bottom: 0;
    color: #777;
}
.footer a {
    color: #444;  
}

/**
 * spike train
 */

#spike-train {
  width: 90%;
  height: 70px;
  margin-top: 20px;
  margin-bottom: -70px;
}
#spike-train .axis,
#spike-train .axis path,
#spike-train .axis line {
    stroke: lightgray;
    fill: none;
    stroke-width: 2px;
    shape-rendering: crispEdges;
}
#spike-train .spike {
    stroke: gray;
    stroke-width: 2px;
}

/**
 * spike count rate
 */

.spike,
.axis path,
.axis line {
  fill: none;
  stroke: gray;
  stroke-width: 1px;
}
.spike {
  stroke: lightgray;
}
.axis {
  font: 10px sans-serif;
  shape-rendering: crispEdges;
}
.brush .extent,
.brush .resize {
  fill-opacity: .1;
  pointer-events: none;
}
.brush .text {
  font: 10px sans-serif;
}
.bar {
  fill-opacity: .7;
  fill: skyblue;
  stroke: steelblue;
}
.bartext {
  font: 10px sans-serif;
}
.slider .handle {
  opacity: .5;
  fill: firebrick;
  stroke: steelblue;
  stroke-width: 1px;
  pointer-events: none;
}

</style>
<title>Firing Rates</title>
<body>
  <header>
    <div class="hero-unit">
      <div class="container">
        <h1>Measuring Firing Rates</h1>
        <div id="spike-train"></div>
        <h1><small>by Robert Costa, 2013 October 13</small></h1>
        <div style="padding-right:30px;">
        <p class="muted" style="line-height:1em;"><small>All methods demonstrated on this web page are based on the subsection <i>Measuring Firing Rates</i> of section <i>1.2 Spike Trains and Firing Rates</i> of <i>Dayan, P., Abbott, L. F., &amp; Abbott, L. (2001). Theoretical neuroscience: Computational and mathematical modeling of neural systems</i>.</small></p>
        <p><b>Neurons</b> communicate with each other by firing so-called
          <b><abbr title="an electrochemical potential">action potentials</abbr></b>.
          A single action potential usually has a
          duration of roughly one millisecond. If we ignore its
          duration, amplitude and shape, we can treat an action potential as
          a stereotypical on-off event, where a single action potential firing
          is called a spike. A sequence of spikes recorded over a single
          <abbr title="usually a time span of several seconds">trial</abbr> is
          called a <b>spike train</b>. If we record multiple trials we can
          average the number of spikes fired at a specific time point over
          these trials. The resulting value is the <b>firing rate</b> of the
          neuron at a specific time point. Since we can only record a limited
          number of trials the real firing rate can only be approximated but
          not determined exactly. In the following we will look at different methods to approximate firing rates. For demonstration purposes only a single spike train will be used. By averaging over multiple trials before applying any of the discussed methods, more accurate results can be achieved.</p>
        </div>
      </div>
    </div>
  </header>
  <div class="container">
    <div class="row-fluid">
      <div class="span3 lead"><b>Spike Count Rate</b></div>
      <div class="span9">
        <p class="lead">The simplest approach to measuring firing rates is to count the number of spikes occurring within a given time frame.</p>
        <div class="row-fluid">
          <div class="span4">
            <p>If we count over the whole trial we get the total number of spikes but loose all temporal resolution.</p>
          </div>
          <div class="span4">
            <p>To know how the spike count changes over time we can subdivide the trial into smaller time bins.</p>
          </div>
          <div class="span4">
            <p>The smaller the time bins the better the temporal resolution. But this comes at the expense of a decreasing rate resolution. For very small time bins the rate can only be either 1 or 0.</p>
          </div>
        </div>
        <div class="row-fluid">
          <div class="span4" id="spike-count-max"></div>
          <div class="span4" id="spike-count-var"></div>
          <div class="span4" id="spike-count-min"></div>
        </div>
      </div>
    </div>
    <div class="row-fluid">
      <div class="span3 lead"><b>Window Function</b></div>
      <div class="span9">
        <p class="lead">Counting spikes in pre-assigned time bins lets the firing rate approximation not only depend on the width of the time bins but also on their placement. By sliding a single time bin over the whole trial duration we can avoid the arbitrariness in placement.</p>
        <div class="row-fluid">
          <div class="span4">Counting spikes within a window around a specific time point avoids arbitrariness in placing of time bins.</div>
          <div class="span4">The resulting firing rate appears to have a better temporal resolution. But at time points close to each other firing rates are correlated.</div>
          <div class="span4">The same spikes are counted for different time points, when those time points have overlapping windows.</div>
        </div>
      </div>
    </div>
    <div class="row-fluid">
      <div class="span3 lead"><b>Linear Filter</b></div>
      <div class="span9">
      </div>
    </div>
    <div class="row-fluid">
      <div class="span3 lead"><b>Causal Kernel</b></div>
      <div class="span9">
      </div>
    </div>
  </div>
  <footer class="footer">
    <div class="container">
      <p class="muted">
        Web page designed by Robert Costa using
        <a href="http://getbootstrap.com">Bootstrap</a>,
        <a href="http://jquery.com/">jQuery</a> and
        <a href="http://d3js.org/">D3.js</a>.
        Bootstrap code is licensed under <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License v2.0</a>, Bootstrap documentation under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.
        jQuery is licensed under the <a href="http://github.com/jquery/jquery/blob/master/MIT-LICENSE.txt">MIT License</a>.
        D3.js is released under <a href="http://opensource.org/licenses/BSD-3-Clause">BSD license</a>.
        <a href="http://glyphicons.com">Glyphicons Free</a> licensed under <a href="http://creativecommons.org/licenses/by/3.0/">CC BY 3.0</a>.
        JavaScript icon by Robert Costa (Own work), licensed under [<a href="http://creativecommons.org/licenses/by-sa/3.0">CC-BY-SA-3.0</a>].
        Google Chrome icon by Umut159 (Own work) [<a href="http://creativecommons.org/licenses/by-sa/3.0">CC-BY-SA-3.0</a>], <a href="http://commons.wikimedia.org/wiki/File%3AGoogle_Chrome_icon_(2011).png">via Wikimedia Commons</a>.
        Mozilla Firefox icon by Mozilla Foundation [<a href="http://www.gnu.org/licenses/gpl.html">GPL</a> or <a href="http://www.gnu.org/licenses/lgpl.html">LGPL</a>], <a href="http://commons.wikimedia.org/wiki/File%3AMozilla_Firefox_3.5_logo_256.png">via Wikimedia Commons</a>.
        Internet Explorer icon copyright by Microsoft Corporation.
        Safari icon copyright by Apple Inc.
        It is believed that the exhibition of icons to illustrate or identify the computer software in question qualifies as fair use under United States copyright law.<br>
        *** Writing this web page was inspired by Bret Victor's web page <i><a href="http://worrydream.com/ScientificCommunicationAsSequentialArt/">Scientific Communication As Sequential Art</a>. ***
      </p>
    </div>
  </footer>
<script src="jquery-1.9.0.min.js" charset="utf-8"></script>
<script src="d3.v3.min.js" charset="utf-8"></script>
<script>
var data = [
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1,
    0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1,
    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0
  ];

/**
 * spike train unter main title
 */

function spikeTrain(parent) {
    var width = $(parent.node()).width(),
        height = 25;

    var xScale = d3.scale.linear().range([0, width - 1]).domain([0, data.length - 1]),
        yScale = d3.scale.linear().range([height - 1, 0]);

    var svg = parent.append('svg')
            .attr('width', width)
            .attr('height', height + 10);

    svg.append("g")
        .classed("x axis", true)
        .attr("transform", "translate(0," + yScale(0) + ")")
        .call(d3.svg.axis().scale(xScale).orient('bottom').ticks(3).tickFormat(''));

    var spikeX = function(d, i) { return xScale(i); };

    svg.selectAll('.bar')
        .data(data)
      .enter().append('line')
        .classed('spike', true)
        .attr('x1', spikeX)
        .attr('x2', spikeX)
        .attr('y1', yScale(0))
        .attr('y2', yScale);
}

spikeTrain(d3.select('#spike-train'));

/**
 * spike count rate graphs
 */

function spikeCountRate(parent, sliderPos, activeSlider) {
    var margin = {top: 15, bottom: 20, left: 15, right: 15},
        width = $(parent.node()).width() - margin.left - margin.right,
        height = 25;

    var xScale = d3.scale.linear().range([0, width - 1]),
        yScale = d3.scale.linear().range([height - 1, 0]);

    var svg = parent.append('svg')
            .attr('width', width + margin.left + margin.right)
            .attr('height', height + margin.top + margin.bottom)
          .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


    svg.append("g")
        .classed("x axis", true)
        .attr("transform", "translate(0," + yScale(0) + ")")
        .call(d3.svg.axis().scale(xScale).orient('bottom').ticks(3).tickFormat(''));

    var spike = svg.selectAll('.spike')
        .data(data)
      .enter().append('line')
        .classed('spike', true)
        .attr('x1', function(d, i) { return xScale(i / data.length); })
        .attr('x2', function(d, i) { return xScale(i / data.length); })
        .attr('y1', yScale(0))
        .attr('y2', yScale);


    var clip = svg.append("defs").append("svg:clipPath")
            .attr("id", "clip")
            .append("svg:rect")
            .attr("id", "clip-rect")
            .attr("x", 0)
            .attr("y", -1)
            .attr("width", width)
            .attr("height", height);
            
    var chartBody = svg.append("g")
        .attr("clip-path", "url(#clip)");

    var rebin = function(deltaT){
        var binData = (function(){
              var bins = [],
                  binwidth = Math.max(Math.round(deltaT * data.length), 1);
              deltaT = binwidth / data.length;
              for (var i = 0; i < data.length; i += binwidth) {
                  var spikecountrate = d3.sum(data.slice(i, i + binwidth));
                  bins.push(spikecountrate);
              }
              return bins;
            })(),
            binXScale = d3.scale.linear().range([0, width - 1]).domain([0, binData.length]),
            binWidth = Math.abs(binXScale(1) - binXScale(0)),
            binYScale = d3.scale.linear().range([height, 0]).domain([0, d3.max(binData)]);

        chartBody.selectAll(".bar").remove();
        chartBody.selectAll(".bar")
            .data(binData)
          .enter().append("rect")
            .attr("class", "bar")
            .attr("x", function(d, i) { return xScale(i * deltaT); })
            .attr("width", xScale(deltaT))
            .attr("y", binYScale)
            .attr("height", function(d) { return height - binYScale(d); });

        svg.selectAll(".bartext").remove();
        var valueSet = d3.set();
        svg.selectAll(".bartext")
            .data(binData)
          .enter().append('text')
            .classed('bartext', true)
            .attr("text-anchor", "middle")
            .attr('y', function(d) { return binYScale(d) - 3; })
            .attr('x', function(d, i){
                var left = xScale(i * deltaT),
                    right = Math.min(xScale((i + 1) * deltaT), width);
                return .5 * (left + right);
            })
            .filter(function(d) {
                if (valueSet.has(d) && xScale(deltaT) < 15) {
                    return false;
                }
                valueSet.add(d);
                return true;
            })
            .text(String);
    }


    var brush = d3.svg.brush()
        .x(xScale)
        .extent([sliderPos, sliderPos])
        .on("brush", brushed);

    var slider = svg.append("g")
        .attr("class", "slider")
        .call(brush);

    slider.selectAll(".extent, .resize")
        .remove();

    slider.select(".background")
        .attr("height", height);

    if (activeSlider) {
        var handle = slider.append("circle")
            .attr("class", "handle")
            .attr("transform", "translate(0," + height + ")")
            .attr("r", 5);

        slider
            .call(brush.event)

        function brushed() {
            var value = brush.extent()[0],
                mouseX = d3.mouse(this)[0];

            if (d3.event.sourceEvent !== null && mouseX) { // not a programmatic event
              value = Math.min(Math.max(xScale.invert(mouseX), 0), 1);
              brush.extent([value, value]);
            }

            handle.attr("cx", xScale(value));
            rebin(value);
        }
        svg.append('rect')
          .attr('class', 'click-capture')
          .style('opacity', 0)
          .attr('x', -margin.top)
          .attr('y', -margin.left)
          .attr('width', width + margin.left + margin.right)
          .attr('height', height + margin.top + margin.bottom)
          .on('mousemove', brushed);
        svg.on('mousemove', brushed);      
    } else {
        brush.extent([sliderPos, sliderPos]);
        rebin(sliderPos);
    }
}

spikeCountRate(d3.select('#spike-count-max'), 1, false);
spikeCountRate(d3.select('#spike-count-var'), .125, true);
spikeCountRate(d3.select('#spike-count-min'), .01, false);

/**
 * window function
 */



</script>
</body>